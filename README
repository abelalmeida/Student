In this lab that I'm going to walk you through, we're going to do some environment setup. We're actually going to do our first lab where we're going to retrieve a bin after the spring application context. When you open up Eclipse, you'll see something like this. The first thing we have to do is to set up what we call a settings file for Maven. This controls how we pull down our dependencies for our project on our build path. We actually have that in this directory here under Settings from your desktop, we'll go and get that. Window preferences, Maven, user settings,

hit ''Browse'', go to Desktop, Settings, Settings XML, open. It's there now, and hit ''Apply''. The next thing we want to do is to open our project that we're going to work in. File, Open Projects, and all our projects are in this student work directory down here. [inaudible] student work.

There's a setup subdirectory and a solutions directory which has the solutions for all the labs, which you can always refer to. Let's go and grab that first project; File, Open Projects in File System. Hit the Directory to input the source. Go to Desktop, Student Work, Setup, select My Project. I can see it's there. Eclipse is going to view it, and we got some activity going down here. It's bringing it into Eclipse. If I close the Welcome tab in the JE perspective, I can see my project is there. It's got some red marks next to it, some problems, it says here. That's because behind the scenes, Eclipse is building this project. Let's open it up and see what this structure of the project is, while it's being built for us by Maven.

We have the part maximum out, which you'll be where we've defined the various dependencies for this project. It's actually a Spring Boot Project, which we'll use in later labs. It has a resources subfolder, which is where we have our bins XML. It has a source folder where we have our source. Our problem domain is actually a service object, which in time will delegate down to data access object. It has one JUnit student service test. Still build some activity, but looks like those red marks have gone away. Our objective is to get student service input out of the application context. We need to configure an application context with some metadata. In this lab, that metadata is going to take the form of XML configuration. I'm going to click on XML File. I'll go into the source and I'll define one bin definition with a primary identifier of student service, and a fully qualified class name of

com.student service,

and the implementation type itself of student service input. Make sure I close that tag off. This content assists in this XML editor in Eclipse. That might be able to help you out. Make sure I save it. What's the next thing we have to do? Well, if I go to the test class, you have to implement a couple of things there. I've put these in myself already to save some time from typing. Here I'm defining a classpath XML application context, giving it the bins XML. Up here is the reference type that can be used. I can actually take that away and just use the interface type.

If I do a "right-click", Source, Organize Input, it's going to say, "Hey, what's this application contexts thing? I'm going to say, well, it's what I want. Now I've got the interface time. Let's clear it up a bit. Down here, I'm getting a bin. That method returns an object. I'm using the primary identifier. Instead of bringing back object, I say cast it to the interface type that the implementation class implements. Let's go and check, make sure that's the case. Yes, it implements that interface. Not done a simple assert, not now. Making sure the service is being retrieved. I'll right-click on the Class. I'll run my JUnit. Looks like it's prompting me to say you didn't save something, so I've saved something.

It's found the XML according to the logs, it's loaded.

We have successfully got a bin out of the application context, the JUnit is green. The key thing here is there's no mention in the client class, which is a JUnit in this case, what the implementation class is. We only have an interface type. If I did go in here and change this to another class that implemented the same interface but had different functionality, I could just re-run the JUnit and it will pick up that new implementation behind the scenes because we're using inversion of control, which is using the interface types here.

This controls how we pull down: Added to Selection. Press [CTRL + S] to save as a note
